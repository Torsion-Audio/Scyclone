#ifndef _RNBO_CoreObject_h_
#define _RNBO_CoreObject_h_

#if defined(USE_DYNAMIC_COMPILATION)
#include <memory>
#endif

#include "RNBO_Types.h"
#include "RNBO_BaseInterface.h"
#include "RNBO_ProbingInterface.h"
#include "RNBO_ParameterEventInterface.h"
#include "RNBO_EventVariant.h"
#include "RNBO_List.h"
#include "RNBO_Array.h"
#include "RNBO_ExternalData.h"
#include "RNBO_DataRef.h"
#include "RNBO_AudioBufferConverter.h"
#include "RNBO_EventList.h"
#include "RNBO_Presets.h"
#include "RNBO_PresetList.h"
#include "RNBO_DataRefList.h"

//#define RNBO_SIMPLEENGINE

namespace RNBO {

	class FileChangeWatcher;
#ifdef RNBO_SIMPLEENGINE
	class EngineCore;
#else
	class Engine;
#endif
	class EventHandler;
	class PatcherChangedHandler;

	/** @mainpage RNBO
	 *
	 *	@section install_sec Getting Started
	 *
	 * The main API for RNBO is the RNBO::CoreObject. It holds all state and data necessary for using RNBO.
	 */
	class CoreObject : public BaseInterface, public ProbingInterface {

	public:

		/**
		 * @brief Construct a new CoreObject
		 *
		 * The CoreObject is the main API for using exported C++ code in external projects. It holds all state and data
		 * necessary for using RNBO.
		 *
		 * @param handler an EventHandler for events generated by the CoreObject
		 */
		CoreObject(EventHandler* handler = nullptr);

		/**
		 * @brief Construct a new CoreObject
		 *
		 * The CoreObject is the main API for using exported C++ code in external projects. It holds all state and data
		 * necessary for using RNBO.
		 *
		 * @param patcher a PatcherInterface to associate with the CoreObject
		 * @param handler an EventHandler for events generated by the CoreObject
		 */
		CoreObject(UniquePtr<PatcherInterface> patcher, EventHandler* handler = nullptr);
		virtual ~CoreObject();

		CoreObject(const CoreObject& other) = delete;
		CoreObject& operator=(const CoreObject& other) = delete;

		CoreObject(CoreObject&& other) = default;
		CoreObject& operator=(CoreObject&& other) = default;


		/* Parameter Interface */

		/**
		 * @brief Get the number of visible parameters
		 *
		 * Note that not all parameters are visible (for example, params in gen~ are not automatically exposed as RNBO
		 * parameters). The count of visible parameters is usually the same as the number of param/param~ objects in
		 * a RNBO~ patch.
		 *
		 * @return the number of visible parameters
		 */
		ParameterIndex getNumParameters() const override;

		/**
		 * @brief Get the parameter name (may not be unique)
		 *
		 * @param index the parameter index
		 * @return a C-style string containing the parameter name
		 */
		ConstCharPointer getParameterName(ParameterIndex index) const override;

		/**
		 * @brief Get the unique ID of a parameter
		 *
		 * The unique ID of a parameter can be the same as the parameter ID.
		 * If a parameter is nested in a subpatcher, a prefix is added to the
		 * parameter name in order to disambiguate. Examples of parameter IDs:
		 *   - "my_toplevel_param"
		 *   - "p_obj-2/my_nested_param"
		 *   - "poly/p_obj-18/my_nested_poly_param"
		 *
		 * @param index the parameter index
		 * @return a C-style string containing the parameter ID
		 */
		ConstCharPointer getParameterId(ParameterIndex index) const override;

		/**
		 * @brief Get detailed information about a parameter
		 *
		 * @param index the parameter index
		 * @param info a pointer to a ParameterInfo object to fill
		 */
		void getParameterInfo(ParameterIndex index, ParameterInfo* info) const override;

		/**
		 * @param index the parameter index
		 * @return the value of the parameter
		 */
		ParameterValue getParameterValue(ParameterIndex index) override;

		/**
		 * @brief Set a parameter's value
		 *
		 * @param index the parameter index
		 * @param value parameter value to set
		 * @param time when the parameter change should happen (default is RNBOTimeNow)
		 */
		void setParameterValue(ParameterIndex index, ParameterValue value, MillisecondTime time = RNBOTimeNow) override;

		/**
		 * @brief Set a parameter's normalized [0..1] value
		 *
		 * @param index the parameter index
		 * @param normalizedValue parameter normalized value to set
		 * @param time when the parameter change should happen (default is RNBOTimeNow)
		 */
		void setParameterValueNormalized(ParameterIndex index, ParameterValue normalizedValue, MillisecondTime time = RNBOTimeNow) override;

		/**
		 * @brief Convert a parameter value from its real value to a normalized representation [0..1]
		 *
		 * @param index the parameter index
		 * @param value the real value of the parameter
		 * @return a normalized ParameterValue
		 */
		ParameterValue convertToNormalizedParameterValue(ParameterIndex index, ParameterValue value) const override;

		/**
		 * @brief Convert a parameter value from a normalized representation [0..1] to its real value
		 *
		 * @param index the parameter index
		 * @param normalizedValue the normalized value
		 * @return the real value of the parameter
		 */
		ParameterValue convertFromNormalizedParameterValue(ParameterIndex index, ParameterValue normalizedValue) const override;

		/**
		 * @brief Apply and get the constrained parameter value
		 *
		 * Parameter constraints include a minimum/maximum value and step constraints
		 *
		 * @param index the parameter index
		 * @param value an unconstrained parameter value
		 * @return the constrained parameter value
		 */
		ParameterValue constrainParameterValue(ParameterIndex index, ParameterValue value) const override;

		/**
		 * @brief Create a lightweight interface for sending and receiving parameter values
		 *
		 * The CoreObject, by default, holds a parameter interface for sending and receiving events with
		 * the non-thread-safe MultiProducer interface type.
		 *
		 * @see RNBO::ParameterEventInterface
		 *
		 * @param type the type of parameter event interface to create
		 * @param handler an event handler
		 * @return a ParameterEventInterfaceUniquePtr
		 */
		ParameterEventInterfaceUniquePtr createParameterInterface(ParameterEventInterface::Type type, EventHandler* handler);

		/**
		 * @brief Schedule an event
		 *
		 * There are a number of event variants that can be scheduled (like MIDI events, tempo events, and parameter
		 * events). For all of the variants available, see the related documentation.
		 *
		 * @see RNBO::EventVariant
		 *
		 * @param event an event to schedule
		 */
		void scheduleEvent(EventVariant event);

		/**
		 * @brief Send a number to named patcher inports
		 *
		 * @param tag the inport name MessageTag created from a char* or const char* via the TAG() function
		 * @param payload a number
		 * @param objectId optionally specify a receiving object (mostly used internally)
		 * @param eventTime time the message should be scheduled for (use RNBOTimeNow or 0 for "as soon as possible")
		 *
		 * For example:
		 * @code{.cpp}
		 * sendMessage(TAG("myinport"), 74, TAG(""), RNBOTimeNow);
		 * @endcode
		 */
		void sendMessage(MessageTag tag, number payload, MessageTag objectId = 0, MillisecondTime eventTime = RNBOTimeNow);

		/**
		 * @brief Send a list message to named patcher inports
		 *
		 * @param tag the inport name MessageTag created from a char* or const char* via the TAG() function
		 * @param payload a UniqueListPtr of numbers
		 * @param objectId optionally specify a receiving object (mostly used internally)
		 * @param eventTime time the message should be scheduled for (use RNBOTimeNow or 0 for "as soon as possible")
		 *
		 * For example:
		 * @code{.cpp}
		 * UniqueListPtr payload = make_unique<list>();
		 * payload.push(0.1);
		 * payload.push(0.2);
		 * sendMessage(TAG("myinport"), payload, TAG(""), RNBOTimeNow);
		 * @endcode
		 */
		void sendMessage(MessageTag tag, UniqueListPtr payload, MessageTag objectId = 0, MillisecondTime eventTime = RNBOTimeNow);

		/**
		 * @brief Send a bang to named patcher inports
		 *
		 * @param tag the inport name MessageTag created from a char* or const char* via the TAG() function
		 * @param objectId optionally specify a receiving object (mostly used internally)
		 * @param eventTime time the message should be scheduled for (use RNBOTimeNow or 0 for "as soon as possible")
		 *
		 * For example:
		 * @code{.cpp}
		 * sendMessage(TAG("myinport"), TAG(""), RNBOTimeNow);
		 * @endcode
		 */
		void sendMessage(MessageTag tag, MessageTag objectId = 0, MillisecondTime eventTime = RNBOTimeNow);

		/**
		 * @brief Look up the name associated with a MessageTag
		 *
		 * @param tag a MessageTag
		 * @return the name associated with the tag as a C-style string
		 */
		MessageTagInfo resolveTag(MessageTag tag) const;

		/**
		 * @return the count of named inports and outports
		 */
		MessageIndex getNumMessages() const;

		/**
		 * @brief Get information about a named inport or outport
		 *
		 * @param index the MessageIndex
		 * @return a reference to the MessageInfo
		 */
		const MessageInfo& getMessageInfo(MessageIndex index) const;

		/**
		 * @return the number of MIDI inputs
		 */
		Index getNumMidiInputPorts() const override;

		/**
		 * @return the number of MIDI outputs
		 */
		Index getNumMidiOutputPorts() const override;

		/* External Data Interface */

		// use the below functions to iterate through the list of external memory references (for example after you received a
		// patcher changed notification) - be aware that the indices will only stay valid until the next patcher rebuild

		/**
		 * @brief Get the number of external memory references
		 *
		 * @see RNBO::ExternalDataRef
		 *
		 * @return the number of external data references
		 */
		ExternalDataIndex getNumExternalDataRefs() const;

		/**
		 * @brief Get the name of an external data reference
		 *
		 * @see RNBO::ExternalDataRef
		 *
		 * @param index the external data reference index
		 * @return a C-style string containing the name of the external data
		 */
		ExternalDataId getExternalDataId(ExternalDataIndex index) const;

		/**
		 * @brief Get more information about an external data reference (like file type and filename)
		 *
		 * @see RNBO::ExternalDataRef
		 *
		 * @param index the index of the external data
		 * @return a struct containing information about the external data
		 */
		const ExternalDataInfo getExternalDataInfo(ExternalDataIndex index) const ;

		/**
		 * @brief Set the contents of an external data reference (thread-safe)
		 *
		 * Note: From the moment setExternalData() is called, memory can and will be used at any given time by RNBO, so
		 * do not reallocate or change the size unless the memory has been released via releaseExternalData().
		 *
		 * @param memoryId the name of the data reference
		 * @param data byte array of data
		 * @param sizeInBytes size of the data array in bytes
		 * @param type buffer type:
		 *               - RNBO::Float32AudioBuffer(Index channels, number samplerate)
		 *               - RNBO::Float64AudioBuffer(Index channels, number samplerate)
		 *               - RNBO::UntypedDataBuffer()
		 * @param callback synchronous callback to be called when the engine releases the memory after
		 *                 releaseExternalData()
		 *
		 * @code{.cpp}
		 * SampleValue buffer[1024];
		 * Float32AudioBuffer bufferType(1, 44100);  // 1 channel, 44100 Hz samplerate
		 * setExternalData("myBuffer", (char *)buffer, 1024 * sizeof(SampleValue), bufferType);
		 * @endcode
		 */
		void setExternalData(ExternalDataId memoryId, char *data, size_t sizeInBytes, DataType type, ReleaseCallback callback = nullptr);

		/**
		 * @brief Release a block of memory (thread-safe)
		 *
		 * Call releaseExternalData() on an external data reference to tell RNBO to stop using a block of memory in a
		 * thread-safe way. If a ReleaseCallback is associated with the data reference, it will be called when the data
		 * is no longer in use.
		 *
		 * @param memoryId the name of the data reference
		 */
		void releaseExternalData(ExternalDataId memoryId);

		/**
		 * @brief Set handlers for an external data reference which will be called before and after processing
		 *
		 * Some clients need to lock and unlock the memory at the beginning and end of processing, and this can be done
		 * by creating an ExternalDataHandler and implementing its processBeginCallback() and processEndCallback()
		 * methods. These will be called synchronously in the audio thread before and after processing, respectively.
		 *
		 * @see RNBO::ExternalDataHandler
		 *
		 * @param handler the ExternalDataHandler to associate with the data reference
		 */
		void setExternalDataHandler(ExternalDataHandler* handler);


		/* Processing Interface */

		/**
		 * @return the current sample rate
		 */
		number getSampleRate() const;

		/**
		 * @return the current vector size
		 */
		Index getSamplesPerBlock() const;

		/**
		 * @brief Set the sample rate and vector size before doing any processing
		 *
		 * This method is almost a no-op when there is no change in sample rate or vector size and force is false (the
		 * default) so it is suitable to call before each processing call. Note that an increase of maxBlockSize will
		 * allocate memory, however.
		 *
		 * If this method returns false, do not call process() afterwards. Instead, call prepareToProcess() again.
		 *
		 * @param sampleRate the sample rate to use
		 * @param maxBlockSize the maximum vector size; actual processing could be made in smaller chunks
		 * @param force if true, ensures the dspsetup methods of patcher objects are called
		 * @return false if called during setPatcher, true otherwise
		 */
		bool prepareToProcess(number sampleRate, size_t maxBlockSize, bool force = false);

		/**
		 * @brief Get the current time (in ms)
		 *
		 * This method is only accurate when called from the audio/processing thread
		 *
		 * @return the current time in milliseconds
		 */
		MillisecondTime getCurrentTime();

		/**
		 * @brief Set the current time (in ms)
		 *
		 * This can be used to tightly sync RNBO and host time. Jumping, rather than forwarding
		 * time according to the processed samples, may result in unpredictable results.
		 *
		 * Do not call this method outside of the audio/processing thread.
		 *
		 * @param time the new time in milliseconds
		 */
		void setCurrentTime(MillisecondTime time);

		/**
		 * @brief Process non-interleaved SampleValue* audio buffers with optional MIDI I/O
		 *
		 * @param audioInputs non-interleaved audio inputs (e.g. a 2D array: SampleValues[numInputs][sampleFrames])
		 * @param numInputs the number of audio input buffers
		 * @param audioOutputs non-interleaved audio outputs (e.g. a 2D array: SampleValues[numOutputs][sampleFrames])
		 * @param numOutputs the number of audio output buffers
		 * @param sampleFrames the number of samples in a single input or output
		 * @param midiInput an optional pointer to a MidiEventList of input events associated with this audio vector
		 * @param midiOutput an optional pointer to a MidiEventList which can receive MIDI output generated during the
		 *                   audio vector
		 */
		void process(const SampleValue* const * audioInputs, Index numInputs,
					 SampleValue* const * audioOutputs, Index numOutputs,
					 Index sampleFrames,
					 const MidiEventList* midiInput = nullptr, MidiEventList* midiOutput = nullptr);

		/**
		 * @brief Convert and process a generic audio buffer with optional MIDI I/O
		 *
		 * In situations where non-interleaved SampleValue* audio buffers are not available (e.g. the audio buffers are
		 * not sizeof(SampleValue) or the buffers are interleaved), use this method to convert and process the audio
		 * buffers.
		 *
		 * @tparam I the type of input audio buffer
		 * @tparam O the type of output audio buffer
		 * @param audioInputs audio input buffers
		 * @param numInputs the number of audio input buffers
		 * @param audioOutputs audio output buffers
		 * @param numOutputs the number of audio output buffers
		 * @param sampleFrames the number of samples in a single input or output
		 * @param midiInput an optional pointer to a MidiEventList of input events associated with this audio vector
		 * @param midiOutput an optional pointer to a
		 */
		template <typename I, typename O>
		void process(I audioInputs, Index numInputs,
					 O audioOutputs, Index numOutputs,
					 Index sampleFrames,
					 const MidiEventList* midiInput = nullptr,
					 MidiEventList* midiOutput = nullptr)
		{
			AudioInBufferConverter<I> audioInBuffer(audioInputs, numInputs, sampleFrames, &_audioInData);
			AudioOutBufferConverter<O> audioOutBuffer(audioOutputs, numOutputs, sampleFrames, &_audioOutData);

			process(audioInBuffer.getReadBuffers(), numInputs,
				audioOutBuffer.getWriteBuffers(), numOutputs,
				sampleFrames,
				midiInput, midiOutput);
		}


		/**
		 * @return the number of audio input channels processed by the current patcher
		 */
		Index getNumInputChannels() const override;

		/**
		 * @return the number of audio output channels processed by the current patcher
		 */
		Index getNumOutputChannels() const override;

		/**
		 * @brief Get the number of signal input parameters
		 *
		 * Signal input parameters can be handed into the processing function as additional audio inputs.
		 *
		 * @return the number of signal input parameters
		 */
		ParameterIndex getNumSignalInParameters() const;

		/**
		 * @brief Get the number of signal output parameters
		 *
		 * Signal input parameters will be handed out of the processing function as additional audio outputs.
		 *
		 * @return the number of signal output parameters
		 */
		ParameterIndex getNumSignalOutParameters() const;


		/* Setting a new patcher */

		/**
		 * @brief Set or replace the engine's patcher with a default patcher
		 *
		 * Note: this blocks audio and event processing.
		 *
		 * @return true on success, false on failure
		 */
		bool setPatcher();

		/**
		 * @brief Replace the engine's patcher with a new instance
		 *
		 * Note: this blocks audio and event processing.
		 *
		 * @param patcher the new patcher instance
		 * @return true on success, false on failure
		 */
		bool setPatcher(UniquePtr<PatcherInterface> patcher);

		/**
		 * @brief Schedule a preset change
		 *
		 * @param preset the new preset
		 */
		void setPreset(UniquePresetPtr preset);

		/**
		 * @brief Set a preset immediately
		 *
		 * Note: this blocks audio and event processing.
		 *
		 * @param preset the new preset
		 */
		void setPresetSync(UniquePresetPtr preset);

		/**
		 * @brief Get a preset (asynchronous)
		 *
		 * The callback is called in the audio thread, so it is inadvisable to do any potentially blocking operations
		 * like opening files or allocating/freeing memory.
		 *
		 * @param callback a PresetCallback to execute when the preset is available
		 */
		void getPreset(PresetCallback callback);

		/**
		 * @brief Get a preset (synchronous)
		 *
		 * Pause event and audio processing to get a preset immediately.
		 *
		 * @return the preset
		 */
		ConstPresetPtr getPresetSync();

#ifndef RNBO_FEATURE_NO_SETPATCHER
		/**
		 * @brief Set the handler for patcher change notifications
		 *
		 * The handler is called synchronously at the end of the setPatcher call and before any audio processing
		 * happens. As such, be aware of taking too much time in the handler.
		 *
		 * @param handler a pointer to a PatcherChangedHandler
		 */
		void setPatcherChangedHandler(PatcherChangedHandler* handler);
#endif


		// Probing interface

		/**
		 * @brief Get the parameter index from a parameter ID
		 *
		 * @param paramid the parameter ID
		 * @return the parameter index
		 */
		ParameterIndex getParameterIndexForID(ConstCharPointer paramid) const;

		/**
		 * @brief Get the number of probing channels associated with an outlet
		 *
		 * Call with outletId = 0 or TAG("") to get the maximum possible number of probing channels
		 *
		 * @param outletId the ID of the outlet
		 * @return the number of probing channels
		 */
		Index getProbingChannels(MessageTag outletId) const override;

	protected:

		void initializeEngine(EventHandler* handler);

#ifdef RNBO_SIMPLEENGINE
		UniquePtr<EngineCore>				_engine;
#else
		UniquePtr<Engine>					_engine;
#endif

	private:
		ParameterEventInterfaceUniquePtr	_parameterInterface;
#ifdef USE_DYNAMIC_COMPILATION
		void initializeFileWatcher(const char* fullPathToCPPSource);
		void fileChanged();
		std::unique_ptr<FileChangeWatcher>	_fileWatcher;
#endif

		AudioBufferConverterData				_audioInData;
		AudioBufferConverterData				_audioOutData;
	};

	class PatcherChangedHandler
	{
	public:
		virtual ~PatcherChangedHandler() {}

		virtual void patcherChanged() = 0;
	};

} // namespace RNBO

#endif  // #ifndef _RNBO_CoreObject_h_
